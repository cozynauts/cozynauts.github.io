<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Samendeck ‚Äì Gartenspiel (Singleplayer)</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #050510;
      color: #f5f5ff;
      display: flex;
      height: 100vh;
    }
    .sidebar {
      width: 270px;
      background: rgba(15, 15, 30, 0.97);
      padding: 20px;
      box-shadow: 2px 0 12px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .sidebar h1 {
      font-size: 1.4rem;
      margin: 0 0 4px;
      color: #d7c2ff;
    }
    .sidebar h2 {
      font-size: 0.95rem;
      margin: 10px 0 4px;
      color: #a9a3ff;
    }
    .stat {
      margin: 0;
      font-size: 0.9rem;
    }
    .stat small {
      opacity: 0.7;
      font-size: 0.75rem;
    }
    .buttons {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    /* Alle Buttons direkt in .buttons bekommen volle Breite */
.buttons > button {
  width: 100%;
}
    button {
      padding: 7px 12px;
      border-radius: 999px;
      border: none;
      background: #7b5dff;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.85rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }
    button.secondary {
      background: rgba(255,255,255,0.08);
      color: #f5f5ff;
      font-weight: 500;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .button-row {
  display: flex;
  gap: 6px;
}

/* Buttons in einer Reihe teilen sich den Platz */
.button-row button {
  flex: 1;
  width: auto; /* √ºberschreibt die 100% von oben */
}

button.danger {
  background: #d94b4b;       /* Roter Button f√ºr "Neues Spiel" */
  color: white;
  font-weight: 600;
}

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      gap: 16px;
    }
    .main h2 {
      margin: 0 0 4px;
      font-size: 1.05rem;
    }
    .zone {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: radial-gradient(circle at top left, rgba(124,96,255,0.14), rgba(0,0,0,0.4));
      padding: 10px;
      min-height: 110px;
    }
    #hand, #played {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

        .zone-boards {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    .board {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .board-field { flex: 4; }
    .board-companions { flex: 2; }
    .board-weather { flex: 1; }

    #field, #companions, #weather {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .plant-card {
      width: 130px;
      padding: 6px;
      border-radius: 10px;
      background: rgba(10, 18, 30, 0.95);
      border: 1px solid rgba(255,255,255,0.18);
      font-size: 0.72rem;
      line-height: 1.2;
    }
    .plant-card-title {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .plant-card-meta {
      font-size: 0.7rem;
      opacity: 0.8;
    }


    .card {
      width: 140px;
      padding: 8px;
      border-radius: 12px;
      background: rgba(20, 18, 40, 0.95);
      border: 1px solid rgba(255,255,255,0.18);
      cursor: pointer;
      font-size: 0.78rem;
      line-height: 1.2;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
    }
    .card-title {
      font-weight: 600;
    }
    .card-tag {
      font-size: 0.7rem;
      opacity: 0.7;
    }
    .card-type {
      font-size: 0.72rem;
      opacity: 0.75;
    }
    .card-desc {
      font-size: 0.72rem;
      opacity: 0.9;
    }

    .card.seed { border-left: 4px solid #8be38b; }
    .card.fertilizer { border-left: 4px solid #f5e38b; }
    .card.weather { border-left: 4px solid #8bd3f5; }
    .card.companion { border-left: 4px solid #f58bd6; }
    .card.tool { border-left: 4px solid #f59e8b; }

    .card.disabled {
      opacity: 0.45;
      cursor: default;
    }

    #log {
      flex: 1;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: radial-gradient(circle at top right, rgba(255,255,255,0.04), rgba(0,0,0,0.5));
      font-size: 0.8rem;
      overflow-y: auto;
      max-height: 200px;
    }
    #log p {
      margin: 2px 0;
    }

        .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none; /* wird per JS auf "flex" gesetzt */
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .help-content {
      max-width: 640px;
      max-height: 80vh;
      overflow-y: auto;
      background: #121225;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 20px 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      font-size: 0.9rem;
    }
    .help-content h2 {
      margin-top: 0;
      margin-bottom: 8px;
      color: #d7c2ff;
    }
    .help-content h3 {
      margin-bottom: 4px;
      margin-top: 12px;
      font-size: 0.95rem;
      color: #cfd4ff;
    }
    .help-content p {
      margin: 4px 0 8px;
    }
    .help-content ul {
      margin: 4px 0 8px 18px;
      padding: 0;
    }
    .help-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      opacity: 0.9;
    }
    .link-btn {
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.3);
      font-size: 0.8rem;
      color: #f5f5ff;
      display: inline-block;
    }
#version-label {
  position: fixed;
  bottom: 8px;
  right: 12px;
  font-size: 0.75rem;
  color: rgba(255,255,255,0.6);
  font-style: italic;
  user-select: none;
}

#version-label a {
  user-select: auto;        /* Link darf wieder markiert/angeklickt werden */
  pointer-events: auto;
  color: #d7c2ff;
  font-weight: 700;
  text-decoration: none;
}

    
  </style>
</head>
<body>
  <aside class="sidebar">
    <h1>Samendeck</h1>
    <p class="stat">Runde: <span id="round">1</span> / <span id="maxRounds">10</span></p>
    <p class="stat">Punkte: <span id="score">0</span></p>
    <p class="stat">Highscore: <span id="bestScore">0</span></p>
    <p class="stat">Deck: <span id="deckSize">0</span> Karten</p>
    <p class="stat">Ablage: <span id="discardSize">0</span> Karten</p>
    <p class="stat">Z√ºge in dieser Runde: <span id="playsLeft">2</span> / <span id="maxPlays">2</span></p>

    <h2>Aktionen</h2>
<div class="buttons">
  <!-- 1. Oben: Runde beenden -->
  <button id="endTurnBtn">Runde beenden</button>

  <!-- 2. Darunter: roter "Neues Spiel"-Button -->
  <button id="restartBtn" class="danger">Neues Spiel</button>

  <!-- 3. Kartendex & Rangliste nebeneinander -->
  <div class="button-row">
    <button class="secondary" onclick="window.open('kartendex.html','_blank')">üìö Kartendex</button>
    <button class="secondary" onclick="window.open('rangliste.html','_blank')">üèÜ Rangliste</button>
  </div>

  <!-- 4. Unten: Hilfe & Patchnotes nebeneinander -->
  <div class="button-row">
    <button id="helpBtn" class="secondary">üìñ Hilfe</button>
    <button class="secondary" onclick="window.open('notes.html','_blank')">üõ†Ô∏è Patchnotes</button>
  </div>
</div>


<p class="stat"><small>
  Klicke Karten in deiner Hand, um sie auszuspielen. Synergien bringen viele Punkte üå±
</small></p>

<h2>üèÖ Top 5 Spieler:innen</h2>
<div id="topPlayers" class="stat" style="font-size:0.85rem; line-height:1.4; opacity:0.9;">
  <em>Lade Rangliste ‚Ä¶</em>
</div>

  </aside>

  <main class="main">
    <section>
      <h2>Hand</h2>
      <div class="zone">
        <div id="hand"></div>
      </div>
    </section>

    <section>
      <h2>In dieser Runde gespielt</h2>
      <div class="zone">
        <div id="played"></div>
      </div>
    </section>

<section>
  <h2>Feld, Begleiter & Wetter</h2>
  <div class="zone zone-boards">
    <div class="board board-field">
      <h3 style="margin:0 0 4px;font-size:0.9rem;">Feld</h3>
      <div id="field"></div>
    </div>
    <div class="board board-companions">
      <h3 style="margin:0 0 4px;font-size:0.9rem;">Aktive Begleiter</h3>
      <div id="companions"></div>
    </div>
    <div class="board board-weather">
      <h3 style="margin:0 0 4px;font-size:0.9rem;">Wetter</h3>
      <div id="weather"></div>
    </div>
  </div>
</section>

    
    <section>
      <h2>Log</h2>
      <div id="log"></div>
    </section>
  </main>

    <!-- Hilfe-Overlay -->
  <div id="helpOverlay" class="help-overlay">
    <div class="help-content">
      <h2>Wie funktioniert Samendeck?</h2>
      <p>
        Du spielst in <strong>7 Runden</strong> mit jeweils
        <strong>2 Z√ºgen</strong>. In jedem Zug spielst du  <strong>bis zu zwei Karten </strong> aus
        deiner Hand, um Punkte zu sammeln oder deine zuk√ºnftigen Z√ºge zu verst√§rken.
      </p>

      <h3>Kurz√ºberblick √ºber die Karten</h3>
      <ul>
        <li><strong>Samen</strong> üå± ‚Äì bringen direkte Punkte.</li>
        <li><strong>D√ºnger</strong> üí© ‚Äì l√§sst alle Pflanzen im Feld schneller wachsen.</li>
        <li><strong>Wetter</strong> üå§Ô∏è ‚Äì beeinflusst Ernten (Sonnenschein) oder Wachstum (Sommerregen).</li>
        <li><strong>Begleiter</strong> üê∂üßô ‚Äì geben dauerhafte Boni und bleiben aktiv.</li>
        <li><strong>Werkzeuge</strong> ‚öíÔ∏è ‚Äì einmalige Spezialeffekte (z. B. Karten nachziehen).</li>
      </ul>

      <h3>Ziel</h3>
      <p>
        Versuche, am Ende von Runde 7 m√∂glichst viele Punkte zu haben.
        Clevere Kombinationen aus Samen, D√ºnger, Wetter und Begleitern
        bringen besonders hohe Werte.
      </p>

      <div class="help-footer">
        <a href="hilfe.html" target="_blank" class="link-btn">
          Ausf√ºhrliche Anleitung in neuem Tab √∂ffnen
        </a>
        <button id="closeHelpBtn" class="secondary">Schlie√üen</button>
      </div>
    </div>
  </div>

<!-- Abschluss-Overlay -->
<div id="endOverlay" class="help-overlay">
  <div class="help-content">
    <h2>üéâ Spiel abgeschlossen!</h2>
    <p id="endScoreLine">
      Du hast insgesamt 0 Punkte erreicht.
    </p>

    <p>
      War das dein bester Run oder bist du im Begriff,
      mit deinem Ergebnis die Rangliste zu erobern?
    </p>

    <p>
      üì∏ Mache einen Screenshot von dieser Ansicht und lade ihn im offiziellen Samendeck-Ranking-Thread hoch:<br>
      <a href="https://discord.com/channels/1335378445131055145/1437953177537351871"
         target="_blank"
         class="link-btn">
        üìÅ Zum Ranglisten-Thread (Discord)
      </a>
    </p>

    <p style="margin-top:8px; opacity:0.8; font-size:0.85rem;">
      Falls du den Beitrag nicht √∂ffnen kannst, tritt zuerst unserem Discord-Server bei:<br>
      <a href="https://discord.gg/nkWaWQwuMj" target="_blank" class="link-btn">üíú Server beitreten</a>
    </p>

    <p>
      Bitte denke daran: <strong>Pro Nutzer ist nur ein Eintrag in der Rangliste m√∂glich.</strong>
    </p>

    <p style="margin-top: 10px;">
      ‚ö†Ô∏è <strong>Wichtig:</strong> Nur Runs von Spieler:innen, die
      <a href="https://www.twitch.tv/tzwehn" target="_blank" style="color:#d7c2ff;">
        dem Twitch-Kanal folgen
      </a>
      k√∂nnen in die Rangliste aufgenommen werden.
    </p>

    <!-- NEU: Log anzeigen -->
    <div class="help-footer" style="justify-content:flex-start; margin-top: 10px;">
      <button id="showLogCopyBtn" class="secondary">üìÑ Log anzeigen</button>
    </div>

    <!-- EINMALIG: Rangliste / Neues Spiel / Schlie√üen -->
    <div class="help-footer" style="justify-content: center; margin-top: 6px;">
      <button id="openLeaderboardBtn" class="secondary">üèÜ Rangliste √∂ffnen</button>
      <button id="restartGameBtn" class="secondary">üîÅ Neues Spiel</button>
      <button id="closeEndBtn" class="secondary" style="margin-left:auto;">Schlie√üen</button>
    </div>
  </div>
</div>



  <script>
    // --- Kartendaten -------------------------------------------------

    const ALL_CARDS = [
      // Samen
// Samen (neues Design)
{
  id: "seed_carrot",
  name: "ü•ï Karotte",
  type: "seed",
  tag: "Gem√ºse",
  growthTime: 2,
  harvestType: "einmalig",
  powerCurve: [1, 3, 5],
description: "Bringt einmalig 5 Punkte nach 2 Wachstumsschritten.",
  synergy: "Profitierst von Ernteboni (D√ºnger)."
},
{
  id: "seed_strawberry",
  name: "üçì Erdbeere",
  type: "seed",
  tag: "Frucht",
  growthTime: 1,
  harvestType: "einmalig",
  // Basis-Erntewert: 2 Punkte
  powerCurve: [2],
  // Text erkl√§rt genau, was passiert
  description: "Einmalige Frucht: bringt 2 Punkte. Bei Sonnenschein zus√§tzlich +2 Punkte.",
  synergy: "Explodiert mit Sonnenschein f√ºr einen schnellen Punktekick."
},
{
  id: "seed_tomato",
  name: "üçÖ Tomate",
  type: "seed",
  tag: "Gem√ºse",
  growthTime: 2,
  harvestType: "wiederholbar",
  powerCurve: [3],
  description: "Wiederholbare Ernte: alle 2 Wachstumsschritte 3 Punkte.",
  synergy: "Mag D√ºnger und Superd√ºnger, besonders wenn mehrere Tomaten im Feld stehen."
},

{
  id: "seed_apple",
  name: "üçé Apfelbaum",
  type: "seed",
  tag: "Baum",
  growthTime: 3,
  harvestType: "dauerhaft",
  // Startet bei 2 Punkten ‚Äì wir steuern den Rest √ºber currentYield
  powerCurve: [2],
description: "Dauerpflanze: erste Ernte 2 Punkte. Nach jeder Ernte steigt der Erntewert dauerhaft um +1.",
  synergy: "Profitiert von D√ºnger und Effekten auf Dauerpflanzen."
},




      // D√ºnger
{
  id: "fert_compost",
  name: "üí© Kompost",
  type: "fertilizer",
  tag: "Basis",
description: "Gibt allen Pflanzen +1 Wachstum (plus Gartenwichtel-Bonus)."
},
{
  id: "fert_super",
  name: "üí© Superd√ºnger",
  type: "fertilizer",
  tag: "Stark",
description: "Verst√§rkt alle Ernten dieser Runde um 50 % (√ó1,5, aufgerundet). L√∂st den Gartenwichtel aus."

},


      // Wetter
      {
        id: "weather_sun",
        name: "‚òÄÔ∏è Sonnenschein",
        type: "weather",
        tag: "Wetter",
      description: "Dauerhaftes Wetter: alle Ernten erhalten +1 Punkt."
      },
      {
        id: "weather_rain",
        name: "üåßÔ∏è Sommerregen",
        type: "weather",
        tag: "Wetter",
     description: "Alle Pflanzen erhalten einmalig +1 Wachstum und wachsen ab sofort pro Runde 1 Schritt schneller."

      },

      // Begleiter
      {
        id: "comp_milo",
        name: "üê∂ Milo, Gartenschn√ºffler",
        type: "companion",
        tag: "Hund",
        description: "Bleibt im Garten und gibt dir bei jeder Ernte dauerhaft +2 Punkte."

      },
{
  id: "comp_gnome",
  name: "üßô‚Äç‚ôÇÔ∏è Gartenwichtel",
  type: "companion",
  tag: "", 
 description: "Gibt +1 Wachstum jedes Mal, wenn du D√ºnger spielst."

},


      // Werkzeuge
      {
        id: "tool_watering",
        name: "Gie√ükanne",
        type: "tool",
        tag: "Werkzeug",
        description: "Wiederholt den letzten D√ºngereffekt."

      },
      {
        id: "tool_rake",
        name: "Rechen",
        type: "tool",
        tag: "Werkzeug",
        description: "Ziehe sofort 2 zus√§tzliche Karten."
      }
    ];

    // --- Spielzustand ------------------------------------------------

const state = {
  round: 1,
  maxRounds: 7,
  score: 0,
  deck: [],
  hand: [],
  discard: [],
  playedThisRound: [],
  maxPlaysPerRound: 2,
  playsLeftThisRound: 2,
  lastSeedPoints: 0,
  lastFertilizerSteps: 0,     // NEU: Wieviel Wachstum gab der letzte D√ºnger?
  lastFertilizerDetail: "",   // NEU: Logtext f√ºr Gie√ükanne (z.B. "1 D√ºnger + 1 Wichtel"),
  weatherSeedBonusThisRound: 0,
  companionSeedBonus: 0,
  companionFertilizerBonus: 0,
  gameOver: false,
  activeCompanions: [],
  activePlants: [],
  activeWeather: null,
  superFertilizerActive: false,
  logEntries: [],
  harvestSummary: {},
  growthLogDone: {},
  miloSummary: { bonuses: [] }      
};


    // --- Helfer ------------------------------------------------------

    function shuffle(array) {
      const arr = array.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function cloneCard(card) {
      return JSON.parse(JSON.stringify(card));
    }

function log(message) {
  const logDiv = document.getElementById("log");
  const p = document.createElement("p");
  p.textContent = message;

  // Neueste Nachricht nach oben im UI
  if (logDiv.firstChild) {
    logDiv.insertBefore(p, logDiv.firstChild);
  } else {
    logDiv.appendChild(p);
  }

  // F√ºr Export in chronologischer Reihenfolge merken
  state.logEntries.push(message);
}


    function drawToHand(targetSize) {
      while (state.hand.length < targetSize) {
        if (state.deck.length === 0) {
          if (state.discard.length === 0) break;
          // Ablagestapel neu mischen
          state.deck = shuffle(state.discard);
          state.discard = [];
          log("Deck gemischt ‚Äì der Ablagestapel wird zum neuen Deck.");
        }
        state.hand.push(state.deck.pop());
      }
    }

    function updateHighscoreIfNeeded() {
      const best = parseInt(localStorage.getItem("samendeck_best") || "0", 10);
      if (state.score > best) {
        localStorage.setItem("samendeck_best", String(state.score));
        log(`üéâ Neuer Highscore! (alter Rekord: ${best} Punkte)`);
      }
    }

    // --- Log kopierbar machen -------------------------------------------------

function openLogCopyOverlay() {
  const box = document.getElementById("logCopyOverlay");
  const textarea = document.getElementById("logCopyText");

  const now = new Date();
  const header = [
    "Samendeck ‚Äì Run-Log",
    `Datum: ${now.toLocaleString("de-DE")}`,
    `Punkte: ${state.score}`,
    `Runden: ${state.round}/${state.maxRounds}`,
    "",
    "Ereignisse:"
  ];

  const lines = header.concat(state.logEntries.map(l => "- " + l));
  textarea.value = lines.join("\n");

  box.style.display = "flex";
}

function copyLogToClipboard() {
  const textarea = document.getElementById("logCopyText");
  textarea.select();
  textarea.setSelectionRange(0, textarea.value.length);
  document.execCommand("copy");
}


    // --- Karten spielen ----------------------------------------------

    function playCard(cardIndex) {
      if (state.gameOver) return;
      if (state.playsLeftThisRound <= 0) {
        log("Du hast in dieser Runde keine Z√ºge mehr √ºbrig.");
        return;
      }

      const card = state.hand[cardIndex];
      if (!card) return;

      state.hand.splice(cardIndex, 1);
      state.playedThisRound.push(card);
      state.playsLeftThisRound--;

      switch (card.type) {
        case "seed":
          handleSeed(card);
          break;
        case "fertilizer":
          handleFertilizer(card);
          break;
        case "weather":
          handleWeather(card);
          break;
        case "companion":
          handleCompanion(card);
          break;
        case "tool":
          handleTool(card);
          break;
      }

      render();
    }

function handleSeed(card) {
  // Neue Samen werden nicht sofort gewertet, sondern in den Garten gesetzt
  card.growth = 0; // bisher absolvierte Pflegeaktionen / Runden
  state.activePlants.push(card);

  log(`üå± ${card.name} wurde gepflanzt (Wachstumszeit: ${card.growthTime} Pflegeaktionen).`);
}


function handleFertilizer(card) {
  if (state.activePlants.length === 0) {
    log(`${card.name} hat keinen Effekt ‚Äì es ist noch keine Pflanze im Garten.`);
    return;
  }

  const gnomeBonus = state.companionFertilizerBonus; // vom Gartenwichtel

  let baseSteps = 0; // Standard: kein Wachstum

  if (card.id === "fert_compost") {
    // üí© Kompost: klassischer Wachstumsd√ºnger
    baseSteps = 1;
  } else if (card.id === "fert_super") {
    // üí© Superd√ºnger: nur Erntebuff, kein eigenes Wachstum
    state.superFertilizerActive = true;
    log("üí• Superd√ºnger aktiviert: Alle Ernten in dieser Runde werden um 50 % verst√§rkt (√ó1,5, aufgerundet).");
  }

  // Wachstum nur durch Basis (Kompost) + Wichtel
  const totalSteps = baseSteps + gnomeBonus;

  const detailParts = [];
  if (baseSteps > 0) detailParts.push(`${baseSteps} D√ºnger`);
  if (gnomeBonus > 0) detailParts.push(`${gnomeBonus} Wichtel`);
  const detail = detailParts.length > 0 ? detailParts.join(" + ") : "nur Wichtel-Effekt";

  // üåø Wirkung auf **alle** aktiven Pflanzen (Wachstum nur, wenn totalSteps > 0)
  state.activePlants.forEach((plant) => {
    if (totalSteps > 0) {
      plant.growth += totalSteps;
      log(
        `üí© ${card.name} d√ºngt ${plant.name} ‚Üí Wachstum +${totalSteps} (${detail}). ` +
        `Fortschritt: ${plant.growth}/${plant.growthTime}`
      );
    } else {
      // z. B. Superd√ºnger ohne Wichtel: kein Wachstum, nur Erntebuff
      if (card.id === "fert_super") {
        log(`üí© ${card.name} wirkt auf ${plant.name}: kein zus√§tzliches Wachstum, aber Erntebuff ist aktiv.`);
      }
    }
  });

    // Infos f√ºr die Gie√ükanne merken
  state.lastFertilizerSteps = totalSteps;
  state.lastFertilizerDetail = detail;

}






function handleWeather(card) {
  // Falls bereits Wetter aktiv ist, wird es ersetzt
  if (state.activeWeather) {
    log(`üå¶Ô∏è Das bisherige Wetter (${state.activeWeather.name}) endet.`);
  }
// Reset alter Wettereffekte
state.weatherSeedBonusThisRound = 0;

  state.activeWeather = card;

  if (card.id === "weather_sun") {
    // Sonne: dauerhafter +1 Erntebonus
    state.weatherSeedBonusThisRound = 1;
    log("‚òÄÔ∏è Neues Wetter: Sonnenschein ‚Üí zuk√ºnftige Samen erhalten dauerhaft +1 Erntebonus.");
  }

  else if (card.id === "weather_rain") {
    // üåßÔ∏è Sommerregen: sofort +2 Punkte
    log("üåßÔ∏è Neues Wetter: Sommerregen aktiviert.");


    // üå± +1 Wachstum f√ºr alle bestehenden Pflanzen (einmalig beim Ausspielen)
    if (state.activePlants.length > 0) {
      state.activePlants.forEach(p => {
        p.growth += 1;
        log(`üíß ${p.name} w√§chst durch den Regen! Fortschritt: ${p.growth}/${p.growthTime}`);
      });
    } else {
      log("üíß Es regnet ‚Äì aber noch sind keine Pflanzen im Feld.");
    }

    // Sommerregen gibt ebenfalls einen dauerhaften +1 Erntebonus
    state.weatherSeedBonusThisRound = 1;
  }

  else {
    state.weatherSeedBonusThisRound = 0;
    log(`üå§Ô∏è Neues Wetter aktiviert: ${card.name}.`);
  }
}

function handleCompanion(card) {
  // Karte in die Liste der aktiven Begleiter aufnehmen (ohne Duplikate)
  if (!state.activeCompanions.some(c => c.id === card.id)) {
    state.activeCompanions.push(card);
  }

  if (card.id === "comp_milo") {
    state.companionSeedBonus += 2;
    log("üê∂ Milo hilft ab jetzt: +2 Punkte auf jeden zuk√ºnftigen Samen.");
  } else if (card.id === "comp_gnome") {
    state.companionFertilizerBonus += 1;
    log("üßô Gartenwichtel ist jetzt aktiv: +1 Wachstum auf jeden zuk√ºnftigen D√ºnger.");
  } else {
    log(`Begleiter gespielt: ${card.name}.`);
  }
}


function handleTool(card) {

  // ‚öíÔ∏è Gie√ükanne ‚Äì NEUE LOGIK
  if (card.id === "tool_watering") {
    const steps = state.lastFertilizerSteps || 0;

    if (steps <= 0) {
      log("‚öíÔ∏è Gie√ükanne: Kein gespeicherter D√ºngereffekt ‚Äì kein zus√§tzlicher Wachstumseffekt.");
      return;
    }

    if (state.activePlants.length === 0) {
      log("‚öíÔ∏è Gie√ükanne: Es sind keine Pflanzen im Feld ‚Äì kein Effekt.");
      return;
    }

    state.activePlants.forEach((plant) => {
      plant.growth += steps;
      log(
        `‚öíÔ∏è Gie√ükanne wiederholt den letzten D√ºngereffekt auf ${plant.name} ` +
        `‚Üí Wachstum +${steps} (${state.lastFertilizerDetail}). ` +
        `Fortschritt: ${plant.growth}/${plant.growthTime}`
      );
    });

    return;
  }

  // üßπ Rechen ‚Äì bleibt unver√§ndert
  else if (card.id === "tool_rake") {
for (let i = 0; i < 2; i++) {
  drawToHand(state.hand.length + 1);
}
    log("üßπ Rechen: Du ziehst 2 zus√§tzliche Karten.");
  }

  // ‚ú® Fallback f√ºr alle anderen Werkzeuge (falls du sp√§ter weitere einbaust)
  else {
    log(`Werkzeug gespielt: ${card.name}.`);
  }
}


// --- Rundenlogik -------------------------------------------------

function harvestPlantOnce(p) {
  // Reife erreicht ‚Üí ‚ÄûEndwert‚Äú der Pflanze
  const matureIndex = p.powerCurve.length - 1;
  let plantBase = p.powerCurve[matureIndex];

  // üçé Apfelbaum: startet bei 2 Punkten und erh√∂ht sich nach jeder Ernte um +1
  if (p.id === "seed_apple") {
    if (typeof p.currentYield !== "number") {
      p.currentYield = 2; // Startwert
    }
    plantBase = p.currentYield;
  }

  const miloBonus = state.companionSeedBonus;

  // ‚òÄÔ∏è Nur Sonnenschein gibt Erntebonus
  let weatherBonus = 0;
  if (state.activeWeather && state.activeWeather.id === "weather_sun") {
    weatherBonus = 1;
  }

  // üçì Spezialfall: Erdbeere + Sonnenschein ‚Üí extra +2
  let strawberrySynergy = 0;
  if (
    p.id === "seed_strawberry" &&
    state.activeWeather &&
    state.activeWeather.id === "weather_sun"
  ) {
    strawberrySynergy = 2;
  }

  // Superd√ºnger-Multiplikator (nur in dieser Runde)
  const baseSum = plantBase + miloBonus + weatherBonus + strawberrySynergy;
  let multiplier = 1;
  if (state.superFertilizerActive) {
    multiplier = 1.5;
  }

  const totalGain = Math.ceil(baseSum * multiplier);

  state.score += totalGain;
  state.lastSeedPoints = totalGain;

  // üîπ Statt direkt loggen ‚Üí f√ºr Zusammenfassung sammeln
  if (!state.harvestSummary[p.id]) {
    state.harvestSummary[p.id] = {
      name: p.name,
      cycles: 0,
      gains: []
    };
  }
  state.harvestSummary[p.id].cycles++;
  state.harvestSummary[p.id].gains.push(totalGain);

  // üê∂ Milo-Beteiligung sammeln (falls aktiv)
  if (miloBonus > 0) {
    if (!state.miloSummary) {
      state.miloSummary = { bonuses: [] };
    }
    state.miloSummary.bonuses.push(miloBonus);
  }

  // Verhalten nach der Ernte je nach Typ
  if (p.harvestType === "einmalig") {
    p.toRemove = true;
    log(`ü•ï ${p.name} wurde entfernt (einmalige Ernte).`);
  } else if (p.harvestType === "wiederholbar") {
    // Tomate & Co.: Info maximal 1x pro Runde loggen (optional)
    if (!state.growthLogDone[p.id]) {
      log(`üçÖ ${p.name} w√§chst weiter.`);
      state.growthLogDone[p.id] = true;
    }
  } else if (p.harvestType === "dauerhaft") {
    if (p.id === "seed_apple") {
      const oldYield = p.currentYield ?? plantBase;
      p.currentYield = oldYield + 1;
      log(`üçé ${p.name} w√§chst weiter: zuk√ºnftiger Basis-Ertrag steigt auf ${p.currentYield} Punkte.`);
    } else {
      state.score += 1;
      log(`üçé ${p.name} tr√§gt weiter Fr√ºchte (+1 Dauerbonuspunkt).`);
    }
  }
}



function endTurn() {
  if (state.gameOver) return;

// üåø 1. Wachstum & Erntephase f√ºr alle aktiven Pflanzen
state.activePlants.forEach((p) => {
  // Basis: jede Runde +1 Wachstum
  let growthStep = 1;

  // üåßÔ∏è Sommerregen aktiv? ‚Üí +1 zus√§tzliches Wachstum pro Runde
  if (state.activeWeather && state.activeWeather.id === "weather_rain") {
    growthStep = 2;
  }

  // Rundenwachstum anwenden
  p.growth += growthStep;

  // üëâ Mehrfach-Ernten erlauben:
  // Solange genug Wachstum f√ºr mindestens eine Ernte vorhanden ist
  // und die Pflanze nicht entfernt wurde (einmalige Ernte)
  while (p.growth >= p.growthTime && !p.toRemove) {
    // Eine Ernte durchf√ºhren (Punkte, Boni, Logs)
    harvestPlantOnce(p);

    if (p.harvestType === "wiederholbar" || p.harvestType === "dauerhaft") {
      // Wiederholbare / dauerhafte Pflanzen: Wachstum um die "Kosten"
      // einer Ernte reduzieren (Tomate: z.B. 4/2 -> nach 1. Ernte 2/2 -> 2. Ernte 0/2)
      p.growth -= p.growthTime;
    } else {
      // Einmalige Pflanzen: nach der Ernte raus, restliches Wachstum egal
      break;
    }
  }
});

// üåø Zusammenfassung der Ernten dieser Runde
for (const plantId in state.harvestSummary) {
  const entry = state.harvestSummary[plantId];
  const total = entry.gains.reduce((a, b) => a + b, 0);

  // Punkte-Details
  const uniqueGains = [...new Set(entry.gains)];

  let gainText = "";
  if (uniqueGains.length === 1) {
    // z. B. (3√ó +3 Punkte = +9)
    gainText = `${entry.cycles}√ó +${uniqueGains[0]} Punkte = +${total}`;
  } else {
    // z. B. (1√ó +4, 1√ó +5 = +9)
    gainText = entry.gains
      .map((g) => `+${g}`)
      .join(", ") + ` = +${total}`;
  }

  log(`üåø ${entry.name} wurde ${entry.cycles}√ó geerntet (${gainText}).`);
}

// üê∂ Zusammenfassung von Milos Hilfe in dieser Runde
if (state.miloSummary && state.miloSummary.bonuses && state.miloSummary.bonuses.length > 0) {
  const count = state.miloSummary.bonuses.length;
  const totalBase = state.miloSummary.bonuses.reduce((a, b) => a + b, 0);
  const unique = [...new Set(state.miloSummary.bonuses)];

  let line = "";

  if (unique.length === 1) {
    const val = unique[0]; // z. B. 2 Punkte pro Ernte
    line = `üê∂ Milo hat bei ${count} Ernte${count > 1 ? "n" : ""} geholfen ` +
           `(${count}√ó +${val} Punkte = +${totalBase} Punkte).`;
  } else {
    // Falls du sp√§ter mal variierende Milo-Boni hast
    const detail = state.miloSummary.bonuses.join(" / ");
    line = `üê∂ Milo hat bei ${count} Ernten geholfen (${detail} Punkte insgesamt = +${totalBase} Punkte).`;
  }

  log(line);
}

// Reset f√ºr n√§chste Runde
state.harvestSummary = {};
state.miloSummary = { bonuses: [] };

  // Entferne abgeerntete Pflanzen
  state.activePlants = state.activePlants.filter(p => !p.toRemove);

  // Superd√ºnger-Effekt gilt nur f√ºr diese Runde
state.superFertilizerActive = false;


  // üåæ 2. Gespielte Karten dieser Runde in Ablage
  state.discard.push(...state.playedThisRound);
  state.playedThisRound = [];
  state.lastFertilizerBonus = 0;
  state.playsLeftThisRound = state.maxPlaysPerRound;

// üåü 3. Pr√ºfen, ob das Spiel vorbei ist (nach Ernte!)
if (state.round >= state.maxRounds) {
  state.gameOver = true;
  render();
  updateHighscoreIfNeeded();
  document.getElementById("endTurnBtn").disabled = true;

  // Text im Abschluss-Overlay aktualisieren
  const endScoreLine = document.getElementById("endScoreLine");
  if (endScoreLine) {
    endScoreLine.textContent = `Du hast insgesamt ${state.score} Punkte erreicht.`;
  }

  // Overlay einblenden
  const endOverlay = document.getElementById("endOverlay");
  if (endOverlay) {
    endOverlay.style.display = "flex";
  }

  log(`‚≠ê Spielende! Du hast insgesamt ${state.score} Punkte erreicht.`);
  log("üéâ √ñffne das Abschlussfenster, um Infos zur Rangliste zu sehen.");

  return;
}




  // üå± 4. Neue Runde vorbereiten
  state.growthLogDone = {};
  state.round += 1;
  drawToHand(state.hand.length + 1);   // genau 1 Karte nachziehen
  render();
  log(`‚Äî Runde ${state.round} startet. ‚Äî`);
}

    // --- Rendering ---------------------------------------------------

  function render() {
  document.getElementById("round").textContent = state.round;
  document.getElementById("maxRounds").textContent = state.maxRounds;
  document.getElementById("score").textContent = state.score;
  document.getElementById("deckSize").textContent = state.deck.length;
  document.getElementById("discardSize").textContent = state.discard.length;
  document.getElementById("playsLeft").textContent = state.playsLeftThisRound;
  document.getElementById("maxPlays").textContent = state.maxPlaysPerRound;

  const best = parseInt(localStorage.getItem("samendeck_best") || "0", 10);
  document.getElementById("bestScore").textContent = best;

  const handDiv = document.getElementById("hand");
  const playedDiv = document.getElementById("played");
  const companionsDiv = document.getElementById("companions");
  const fieldDiv = document.getElementById("field");
  const weatherDiv = document.getElementById("weather");

  handDiv.innerHTML = "";
  playedDiv.innerHTML = "";
  if (companionsDiv) companionsDiv.innerHTML = "";
  if (fieldDiv) fieldDiv.innerHTML = "";
  if (weatherDiv) weatherDiv.innerHTML = "";

  // Hand rendern
  state.hand.forEach((card, index) => {
    const div = document.createElement("div");
    div.className =
      "card " +
      card.type +
      (state.playsLeftThisRound <= 0 || state.gameOver ? " disabled" : "");

    const typeLabel = {
      seed: "Samen",
      fertilizer: "D√ºnger",
      weather: "Wetter",
      companion: "Begleiter",
      tool: "Werkzeug",
    }[card.type] || card.type;

    div.innerHTML = `
      <div class="card-header">
        <span class="card-title">${card.name}</span>
        <span class="card-tag">${card.tag || ""}</span>
      </div>
      <div class="card-type">${typeLabel}</div>
      <div class="card-desc">${card.description}</div>
    `;

    if (!state.gameOver && state.playsLeftThisRound > 0) {
      div.addEventListener("click", () => playCard(index));
    }
    handDiv.appendChild(div);
  });

  // Diese Runde gespielte Karten
  state.playedThisRound.forEach((card) => {
    const div = document.createElement("div");
    div.className = "card " + card.type + " disabled";

    const typeLabel = {
      seed: "Samen",
      fertilizer: "D√ºnger",
      weather: "Wetter",
      companion: "Begleiter",
      tool: "Werkzeug",
    }[card.type] || card.type;

    div.innerHTML = `
      <div class="card-header">
        <span class="card-title">${card.name}</span>
        <span class="card-tag">${card.tag || ""}</span>
      </div>
      <div class="card-type">${typeLabel}</div>
      <div class="card-desc">${card.description}</div>
    `;
    playedDiv.appendChild(div);
  });

  // Aktive Begleiter & dauerhafte Effekte
  if (companionsDiv) {
    state.activeCompanions.forEach((card) => {
      const div = document.createElement("div");
      div.className = "card " + card.type + " disabled";

      let effectText = card.description;
      if (card.id === "comp_milo") {
        effectText += ` (aktuell +${state.companionSeedBonus} auf Samen)`;
      } else if (card.id === "comp_gnome") {
  effectText += ` (aktuell +${state.companionFertilizerBonus} Wachstum auf D√ºnger)`;
}

      div.innerHTML = `
        <div class="card-header">
          <span class="card-title">${card.name}</span>
          <span class="card-tag">${card.tag || ""}</span>
        </div>
        <div class="card-type">Begleiter</div>
        <div class="card-desc">${effectText}</div>
      `;
      companionsDiv.appendChild(div);
    });
  }

  // Feld / aktive Pflanzen
  if (fieldDiv) {
    if (state.activePlants.length === 0) {
      const info = document.createElement("p");
      info.style.fontSize = "0.75rem";
      info.style.opacity = "0.8";
      info.textContent = "Noch keine Pflanzen gesetzt.";
      fieldDiv.appendChild(info);
    } else {
      state.activePlants.forEach((plant) => {
        const div = document.createElement("div");
        div.className = "plant-card";

        const currentGrowth = plant.growth || 0;
        let progress;
        let extraInfo = "";

        // üå± Einmalige Pflanzen (z. B. Karotte, Erdbeere)
        if (plant.harvestType === "einmalig") {
          const reached = currentGrowth >= plant.growthTime;
          const clamped = Math.min(currentGrowth, plant.growthTime);

          // Anzeige z.B. "1/1" oder "2/2"
          progress = `${clamped}/${plant.growthTime}`;

          if (reached) {
            extraInfo = " (ausgewachsen)";
          }

        // üçÖ / üçé Wiederholbare / dauerhafte Pflanzen mit Mehrfach-Ernte
        } else {
          const cycles = Math.floor(currentGrowth / plant.growthTime);
          const remainder = currentGrowth % plant.growthTime;

          progress = `${remainder}/${plant.growthTime}`;

          if (cycles > 0) {
            progress += ` (+${cycles} Ernte${cycles > 1 ? "n" : ""} bereit bei Rundenende)`;
          }
        }

        let harvestLabel = "";
        if (plant.harvestType === "einmalig") harvestLabel = "Einmalige Ernte";
        else if (plant.harvestType === "wiederholbar") harvestLabel = "Wiederholbar";
        else if (plant.harvestType === "dauerhaft") harvestLabel = "Dauerhaft";

        div.innerHTML = `
          <div class="plant-card-title">${plant.name}</div>
          <div class="plant-card-meta">
            Fortschritt: ${progress}${extraInfo}
          </div>
          <div class="plant-card-meta">${harvestLabel}</div>
        `;

        fieldDiv.appendChild(div);
      });
    }
  }


// Wetter-Anzeige
if (weatherDiv) {
  const p = document.createElement("p");
  p.style.fontSize = "0.75rem";
  p.style.opacity = "0.85";

  if (state.activeWeather) {
    if (state.activeWeather.id === "weather_sun") {
      p.textContent = `Aktives Wetter: ${state.activeWeather.name} (+1 Erntebonus).`;
    } else if (state.activeWeather.id === "weather_rain") {
      p.textContent = `Aktives Wetter: ${state.activeWeather.name} (schnelleres Wachstum f√ºr alle Pflanzen).`;
    } else {
      p.textContent = `Aktives Wetter: ${state.activeWeather.name}.`;
    }
  } else {
    p.textContent = "Kein aktives Wetter.";
  }

  weatherDiv.appendChild(p);
}

}


    // --- Init --------------------------------------------------------

function initGame() {
  state.round = 1;
  state.score = 0;
  state.discard = [];
  state.hand = [];
  state.playedThisRound = [];
  state.maxPlaysPerRound = 2;           
  state.playsLeftThisRound = state.maxPlaysPerRound;
  state.lastSeedPoints = 0;
  state.lastFertilizerBonus = 0;
  state.weatherSeedBonusThisRound = 0;
  state.companionSeedBonus = 0;
  state.companionFertilizerBonus = 0;
  state.gameOver = false;
  state.activeCompanions = [];
  state.activePlants = [];
  state.activeWeather = null;
  state.superFertilizerActive = false;
  state.logEntries = [];

  

  // Deck bauen ‚Ä¶
  const deck = [];
  ALL_CARDS.forEach(card => {
    let copies = 2;
    if (card.type === "companion" || card.type === "tool" || card.type === "weather") {
      copies = 1;
    }
    for (let i = 0; i < copies; i++) {
      deck.push(cloneCard(card));
    }
  });

  state.deck = shuffle(deck);
  drawToHand(7);              // üëà Start: 7 Karten
  render();

  document.getElementById("endTurnBtn").disabled = false;

  const logDiv = document.getElementById("log");
  logDiv.innerHTML = "";
  log("Neues Spiel gestartet. Versuche in 7 Runden so viele Punkte wie m√∂glich zu sammeln!");
}


document.addEventListener("DOMContentLoaded", () => {
  document.getElementById("endTurnBtn").addEventListener("click", endTurn);
  document.getElementById("restartBtn").addEventListener("click", initGame);

  // Bestehende Elemente
  const helpBtn = document.getElementById("helpBtn");
  const helpOverlay = document.getElementById("helpOverlay");
  const closeHelpBtn = document.getElementById("closeHelpBtn");
  const endOverlay = document.getElementById("endOverlay");
  const closeEndBtn = document.getElementById("closeEndBtn");
  const restartGameBtn = document.getElementById("restartGameBtn");
  const openLeaderboardBtn = document.getElementById("openLeaderboardBtn");
  const showLogCopyBtn = document.getElementById("showLogCopyBtn");  
  const logCopyOverlay = document.getElementById("logCopyOverlay");   
  const closeLogCopyBtn = document.getElementById("closeLogCopyBtn"); 
  const copyLogBtn = document.getElementById("copyLogBtn");           


  // --- Hilfe-Overlay ---
  if (helpBtn && helpOverlay && closeHelpBtn) {
    helpBtn.addEventListener("click", () => {
      helpOverlay.style.display = "flex"; // √∂ffnet
    });

    closeHelpBtn.addEventListener("click", () => {
      helpOverlay.style.display = "none"; // schlie√üt
    });

    helpOverlay.addEventListener("click", (e) => {
      if (e.target === helpOverlay) {
        helpOverlay.style.display = "none"; // Klick au√üerhalb schlie√üt ebenfalls
      }
    });
  }

  // --- Abschluss-Overlay ---
  if (endOverlay && closeEndBtn) {
    closeEndBtn.addEventListener("click", () => {
      endOverlay.style.display = "none";
    });

    endOverlay.addEventListener("click", (e) => {
      if (e.target === endOverlay) {
        endOverlay.style.display = "none";
      }
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      endOverlay.style.display = "none";
      initGame(); // Neues Spiel starten
    });
  }

  if (openLeaderboardBtn) {
    openLeaderboardBtn.addEventListener("click", () => {
      window.open("rangliste.html", "_blank"); // √∂ffnet Rangliste in neuem Tab
    });
  }

    // --- Log-Overlay √∂ffnen ---
  if (showLogCopyBtn) {
    showLogCopyBtn.addEventListener("click", openLogCopyOverlay);
  }

  // --- Log-Overlay schlie√üen ---
  if (closeLogCopyBtn && logCopyOverlay) {
    closeLogCopyBtn.addEventListener("click", () => {
      logCopyOverlay.style.display = "none";
    });

    logCopyOverlay.addEventListener("click", (e) => {
      if (e.target === logCopyOverlay) {
        logCopyOverlay.style.display = "none";
      }
    });
  }

  // --- Log in Zwischenablage kopieren ---
  if (copyLogBtn) {
    copyLogBtn.addEventListener("click", copyLogToClipboard);
  }


  // Spiel starten
  loadMiniLeaderboard();
  initGame();

// --- Mini-Rangliste in der Sidebar laden ---
async function loadMiniLeaderboard() {
  try {
    const response = await fetch("rangliste.csv?cb=" + Date.now());
    const text = await response.text();
    const rows = text.trim().split("\n").slice(1); // Kopfzeile raus

    const data = rows.map(row => {
      const [time, date, name, score] = row.split(";");
      return { name: name.trim(), score: parseInt(score, 10), date: date.trim() };
    });

    // Sortieren & Top 5 nehmen
    const top5 = data.sort((a, b) => b.score - a.score).slice(0, 5);

    const div = document.getElementById("topPlayers");
    div.innerHTML = top5
  .map(
    (p, i) =>
      `${i + 1}. üå± <strong>${p.score}</strong> Punkte ‚Äì ${p.name} ` +
      `<span style="font-size:0.5rem; opacity:0.6;">(${p.date})</span>`
  )
  .join("<br>");

  } catch (err) {
    console.error("Fehler beim Laden der Rangliste:", err);
    const div = document.getElementById("topPlayers");
    div.innerHTML = "<em>Keine Ranglistendaten gefunden.</em>";
  }
}



});


  </script>
<div id="version-label">
  v0.6 ‚Äì Garten-Update üå± ‚Ä¢ 
  Erstellt von 
<a href="https://www.twitch.tv/tzwehn" target="_blank"
   style="color:#d7c2ff; font-weight:700; text-decoration:none;">
  üíú Tzwehn
</a>

</div>


<script>
  // üîÑ Zeigt Datum & Uhrzeit des letzten Updates (laut Dateisystem)
  const versionLabel = document.getElementById("version-label");
  if (versionLabel) {
    fetch(window.location.href, { method: "HEAD" })
      .then((res) => {
        const lastMod = res.headers.get("last-modified");
        if (lastMod) {
          const date = new Date(lastMod);
          const formatted = date.toLocaleString("de-DE", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
            hour: "2-digit",
            minute: "2-digit",
          });
          versionLabel.innerHTML += ` ‚Ä¢ Stand: ${formatted}`;
        }
      })
      .catch(() => {
        versionLabel.innerHTML += " ‚Ä¢ Stand: unbekannt";
      });
  }
</script>


</body>
</html>
